import React, { useEffect, useState, useCallback, useMemo, useRef } from 'react'
import * as api from './api/todos'
import TodoInput from './components/TodoInput'
import TodoList from './components/TodoList'
import ThemeToggle from './components/ThemeToggle'
import ThemeSelector from './components/ThemeSelector'
import DiagnosticsPanel from './components/DiagnosticsPanel'
import useApiCache from './hooks/useApiCache'
import './animations.css'
import './theme.css'

export default function App() {
    const [activeTab, setActiveTab] = useState('todos')
    const [error, setError] = useState(null)
    const [showDiagnostics, setShowDiagnostics] = useState(false)
    const [currentTheme, setCurrentTheme] = useState('light')

    // Track theme changes
    useEffect(() => {
        const getTheme = () => {
            const savedTheme = localStorage.getItem('theme') || 'light';
            setCurrentTheme(savedTheme);
        };

        // Set initial theme
        getTheme();

        // Listen for theme changes from storage
        const handleStorageChange = (e) => {
            if (e.key === 'theme') {
                getTheme();
            }
        };
        
        // Also listen for dark mode changes
        const handleDarkModeChange = () => {
            getTheme();
        };

        window.addEventListener('storage', handleStorageChange);
        window.addEventListener('darkmodechange', handleDarkModeChange);
        
        return () => {
            window.removeEventListener('storage', handleStorageChange);
            window.removeEventListener('darkmodechange', handleDarkModeChange);
        };
    }, [])

    // Use separate API caches for todos and archives
    const {
        data: todos,
        loading: todosLoading,
        error: todosError,
        fetchData: fetchTodos,
        optimisticUpdate: optimisticTodosUpdate
    } = useApiCache([])

    const {
        data: archives,
        loading: archivesLoading,
        error: archivesError,
        fetchData: fetchArchives,
        optimisticUpdate: optimisticArchivesUpdate
    } = useApiCache([])

    // Combine errors from both caches
    useEffect(() => {
        setError(todosError || archivesError)
    }, [todosError, archivesError])

    // Memoize loading state to prevent unnecessary re-renders
    const loading = useMemo(() => {
        return activeTab === 'todos' ? todosLoading : archivesLoading
    }, [activeTab, todosLoading, archivesLoading])

    const loadTodos = useCallback(async () => {
        try {
            await fetchTodos(() => api.getTodos())
        } catch (error) {
            console.error('Failed to load todos:', error)
        }
    }, [fetchTodos])

    const loadArchives = useCallback(async () => {
        try {
            await fetchArchives(() => api.getArchives())
        } catch (error) {
            console.error('Failed to load archives:', error)
        }
    }, [fetchArchives])

    const handleAdd = useCallback(async (text) => {
        try {
            // Create the optimistic update with temporary data
            const optimisticTodo = {
                task: text,
                TODO: text // Backend format
            }

            await optimisticTodosUpdate(
                'add',
                optimisticTodo,
                () => api.addTodo(text)
            )
            return true
        } catch (error) {
            console.error('Failed to add todo:', error)
            return false
        }
    }, [optimisticTodosUpdate]);

    const handleArchive = useCallback(async (todo) => {
        try {
            console.log('Archiving todo:', todo); // Debug log

            if (!todo) {
                console.error('Attempt to archive undefined/null todo');
                setError('Cannot archive: invalid task object');
                return;
            }

            // Make sure we're using the correct ID
            const todoId = todo.id;

            if (todoId === undefined || todoId === null) {
                console.error('Todo ID is undefined or null:', todo);
                setError('Cannot archive task: missing task ID.');
                return;
            }

            // Check for temporary ID pattern (generated by optimisticUpdate)
            if (typeof todoId === 'string' && todoId.startsWith('temp-')) {
                console.warn('Attempting to archive a task with a temporary ID:', todoId);
                setError('This task is being saved. We\'ll archive it once it\'s saved.');

                // Schedule a retry after a short delay (1 second)
                setTimeout(() => {
                    // Check if the task has been replaced with a real ID in the meantime
                    const updatedTask = todos.find(t => t._original && t._original.tempId === todoId);
                    if (updatedTask && updatedTask.id && !updatedTask.id.toString().startsWith('temp-')) {
                        console.log('Temporary task now has permanent ID, retrying archive:', updatedTask);
                        handleArchive(updatedTask);
                    } else {
                        console.log('Task still has temporary ID or was not found, cannot archive yet:', todoId);
                    }
                }, 1000);
                return;
            }

            // Ensure we have a numeric ID for the API
            const parsedId = typeof todoId === 'string' ? parseInt(todoId, 10) : todoId;

            if (isNaN(parsedId)) {
                console.error(`Invalid todo ID format (not a number): ${todoId}`);
                setError('Cannot archive task: ID is not a valid number.');
                return;
            }

            // Get task content
            const taskContent = todo.task || todo.TODO || '';
            if (!taskContent) {
                console.warn('Todo being archived has no content:', todo);
                // Continue anyway, but log the warning
            }

            console.log(`Starting archive process for task ID: ${parsedId} with content: "${taskContent}"`);

            // First make the API call to avoid race conditions
            console.log(`Making API call to archive task ID: ${parsedId}`);
            const response = await api.archiveTodo(parsedId);
            console.log('Archive API response:', response);

            if (response && response.status === 200) {
                const newArchiveId = response.data.archived_task_id;
                console.log(`Task archived successfully with new archive ID: ${newArchiveId}`);

                // Now that we know the API call was successful, update the UI
                // Remove from todos optimistically
                optimisticTodosUpdate(
                    'remove',
                    { ...todo, id: parsedId }, // Ensure consistent ID format 
                    () => Promise.resolve() // API call already made
                );

                // Create the archived item
                const archivedItem = {
                    id: newArchiveId,
                    task: taskContent,
                    Finished: taskContent // Backend format
                };

                console.log('Adding to archives list:', archivedItem);

                // Add to archives
                optimisticArchivesUpdate(
                    'add',
                    archivedItem,
                    () => Promise.resolve() // API call already made
                );

                // Clear any previous error
                setError(null);
            } else {
                console.warn('Unexpected response format from archive API:', response);
                setError('Unexpected response from the server.');
            }
            return response;
        } catch (error) {
            console.error('API error during archive:', error);

            // Set a detailed error message
            const errorMessage = error.response?.data?.error ||
                error.message ||
                'Unknown error during archive operation';

            setError(`Archive failed: ${errorMessage}`);

            // Show error message in console with details
            console.error('Failed to archive todo:', error);
        }
    }, [optimisticTodosUpdate, optimisticArchivesUpdate, setError])
    const handleUnarchive = useCallback(async (archive) => {
        try {
            if (!archive) {
                console.error('Attempt to unarchive undefined/null archive');
                setError('Cannot unarchive: invalid archive object');
                return;
            }

            // Make sure we're using the correct ID
            const archiveId = archive.id;

            if (archiveId === undefined || archiveId === null) {
                console.error('Archive ID is undefined or null:', archive);
                setError('Cannot unarchive: missing archive ID.');
                return;
            }

            // Ensure we have a numeric ID for the API
            const parsedId = typeof archiveId === 'string' ? parseInt(archiveId, 10) : archiveId;

            if (isNaN(parsedId)) {
                console.error(`Invalid archive ID format (not a number): ${archiveId}`);
                setError('Cannot unarchive: ID is not a valid number.');
                return;
            }

            // Get task content
            const taskContent = archive.task || archive.Finished || '';
            if (!taskContent) {
                console.warn('Archive being unarchived has no content:', archive);
                // Continue anyway, but log the warning
            }

            console.log(`Unarchiving archive with ID: ${parsedId}`);

            // First call the API and ensure it succeeds
            try {
                const response = await api.unarchiveTodo(parsedId);
                console.log('Unarchive API response:', response);

                if (response && response.status === 200) {
                    const newTaskId = response.data.task_id;
                    console.log(`Archive unarchived successfully with new task ID: ${newTaskId}`);

                    // Remove from archives optimistically
                    optimisticArchivesUpdate(
                        'remove',
                        { ...archive, id: parsedId }, // Ensure consistent ID format
                        () => Promise.resolve() // API call already made
                    );

                    // Create the unarchived task item
                    const unArchivedItem = {
                        id: newTaskId,
                        task: taskContent,
                        TODO: taskContent // Backend format
                    };

                    console.log('Adding to todos list:', unArchivedItem);

                    // Add to todos
                    optimisticTodosUpdate(
                        'add',
                        unArchivedItem,
                        () => Promise.resolve() // API call already made
                    );

                    // Clear any previous error
                    setError(null);
                } else {
                    console.warn('Unexpected response format from unarchive API:', response);
                    setError('Unexpected response from the server.');
                }
            } catch (apiError) {
                console.error('API error during unarchive:', apiError);
                const errorMessage = apiError.response?.data?.error || apiError.message || 'Unknown error';
                setError(`Failed to unarchive: ${errorMessage}`);
            }
        } catch (error) {
            console.error('Failed to unarchive archive:', error);
            setError('An unexpected error occurred while unarchiving.');
        }
    }, [optimisticArchivesUpdate, optimisticTodosUpdate, setError]);

    const handleDelete = useCallback(async (archive) => {
        try {
            if (!archive) {
                console.error('Attempt to delete undefined/null archive');
                setError('Cannot delete: invalid archive object');
                return;
            }

            // Make sure we're using the correct ID
            const archiveId = archive.id;

            if (archiveId === undefined || archiveId === null) {
                console.error('Archive ID is undefined or null:', archive);
                setError('Cannot delete archive: missing archive ID.');
                return;
            }

            // Ensure we have a numeric ID for the API
            const parsedId = typeof archiveId === 'string' ? parseInt(archiveId, 10) : archiveId;

            if (isNaN(parsedId)) {
                console.error(`Invalid archive ID format (not a number): ${archiveId}`);
                setError('Cannot delete archive: ID is not a valid number.');
                return;
            }
            console.log(`Deleting archive with ID: ${parsedId}`);

            // First call the API and ensure it succeeds
            try {
                const response = await api.deleteTodo(parsedId);
                console.log('Delete API response:', response);

                // Only update the UI after successful API call
                optimisticArchivesUpdate(
                    'remove',
                    { ...archive, id: parsedId }, // Ensure consistent ID format
                    () => Promise.resolve() // API call already made
                );

                // Clear any previous error on success
                setError(null);
            } catch (apiError) {
                console.error('API error during delete:', apiError);
                const errorMessage = apiError.response?.data?.error || apiError.message || 'Unknown error';
                setError(`Failed to delete archive: ${errorMessage}`);
                // Don't throw the error as it's already caught and handled here
            }
        } catch (error) {
            console.error('Failed to delete archive:', error);
            const errorMessage = error.response?.data?.error || error.message || 'Unknown error';
            setError(`Failed to delete archive: ${errorMessage}`);
        }
    }, [optimisticArchivesUpdate, setError])
    // Load data when tab changes using a more efficient approach
    const handleTabChange = useCallback((tab) => {
        setActiveTab(tab);

        // Only fetch data if we haven't loaded it yet
        if (tab === 'todos' && todos.length === 0 && !todosLoading) {
            loadTodos();
        } else if (tab === 'archives' && archives.length === 0 && !archivesLoading) {
            loadArchives();
        }
    }, [todos.length, archives.length, todosLoading, archivesLoading, loadTodos, loadArchives]);

    // Initial data loading
    useEffect(() => {
        if (activeTab === 'todos') {
            loadTodos();
        } else if (activeTab === 'archives') {
            loadArchives();
        }
    }, []);  // Map data from backend format to frontend format
    const mappedTodos = useMemo(() => {
        // Handle case where todos is null, undefined or not an array
        if (!todos || !Array.isArray(todos) || todos.length === 0) {
            return [];
        }

        return todos.map(todo => {
            // Skip null or undefined items
            if (!todo) {
                console.warn('Encountered null/undefined todo item');
                return null;
            }

            // Debug mapping process
            console.log('Mapping todo from backend:', todo);

            // Ensure ID is a number for consistency
            let id = todo.id;
            if (typeof id === 'string') {
                id = parseInt(id, 10);
                if (isNaN(id)) {
                    console.warn(`Found invalid ID format in todo: ${todo.id}`);
                    // Use original ID if we can't parse it
                    id = todo.id;
                }
            }

            return {
                id,
                task: todo.TODO || todo.task,  // Handle both backend and optimistic format
                completed: false,
                // Preserve original data for debugging
                _original: todo
            };
        }).filter(Boolean); // Filter out any null items
    }, [todos]);

    const mappedArchives = useMemo(() => {
        // Handle case where archives is null, undefined or not an array
        if (!archives || !Array.isArray(archives) || archives.length === 0) {
            return [];
        }

        return archives.map(archive => {
            // Skip null or undefined items
            if (!archive) {
                console.warn('Encountered null/undefined archive item');
                return null;
            }

            // Ensure ID is a number for consistency
            let id = archive.id;
            if (typeof id === 'string') {
                id = parseInt(id, 10);
                if (isNaN(id)) {
                    console.warn(`Found invalid ID format in archive: ${archive.id}`);
                    // Use original ID if we can't parse it
                    id = archive.id;
                }
            }

            return {
                id,
                task: archive.Finished || archive.task,  // Handle both backend and optimistic format
                completed: true,        // Preserve original data for debugging
                _original: archive
            };
        }).filter(Boolean); // Filter out any null items
    }, [archives]);


    // Use ref for AnimeJS animations
    // No need for a ref since we're using CSS animations

    return (
        <div className="app-container min-h-screen py-8 px-4 transition-colors duration-300">
            {/* Background particles for visual effect */}
            <div className="absolute inset-0 overflow-hidden pointer-events-none z-0">
                {[...Array(8)].map((_, i) => (
                    <div
                        key={i}
                        className={`absolute rounded-full animate-float 
              ${i % 2 === 0 ? 'bg-indigo-500' : 'bg-blue-400'} 
              ${currentTheme === 'nature' ? 'bg-nature-400' : ''}
              opacity-5 dark:opacity-10`}
                        style={{
                            width: `${20 + Math.floor(Math.random() * 80)}px`,
                            height: `${20 + Math.floor(Math.random() * 80)}px`,
                            top: `${10 + Math.floor(Math.random() * 80)}%`,
                            left: `${10 + Math.floor(Math.random() * 80)}%`,
                            animationDelay: `${i * 0.2}s`,
                        }}
                    />
                ))}
            </div>

            <div className="max-w-4xl mx-auto card rounded-xl shadow-lg overflow-hidden transition-colors duration-300 relative z-10">
                <div className="p-8">
                    <div className="flex justify-between items-center mb-6">            <h1 className="text-3xl font-bold text-indigo-800 dark:text-indigo-300 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8 mr-2 text-indigo-600 dark:text-indigo-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" />
                        </svg>
                        My TODO List
                    </h1>
                        <div className="flex items-center space-x-2">
                            <button
                                onClick={() => setShowDiagnostics(!showDiagnostics)}
                                className="p-2 rounded-full bg-indigo-100 dark:bg-indigo-900 text-indigo-700 dark:text-indigo-300 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors duration-200"
                                title="Toggle diagnostics panel"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z" />
                                </svg>
                            </button>
                            <div className="flex items-center space-x-2">
                                <ThemeToggle />
                                <ThemeSelector />
                            </div>
                        </div>
                    </div>

                    <div className="flex mb-6 border-b dark:border-gray-700">
                        <button
                            onClick={() => handleTabChange('todos')}
                            className={`py-2 px-4 transition-colors duration-200 ${activeTab === 'todos'
                                    ? currentTheme === 'nature'
                                        ? 'border-b-2 border-nature-600 text-nature-800 dark:text-nature-300 font-medium'
                                        : 'border-b-2 border-indigo-600 text-indigo-800 dark:text-indigo-300 font-medium'
                                    : currentTheme === 'nature'
                                        ? 'text-gray-600 hover:text-nature-600 dark:text-gray-400 dark:hover:text-nature-300'
                                        : 'text-gray-500 hover:text-indigo-600 dark:text-gray-400 dark:hover:text-indigo-300'
                                }`}
                        >
                            Active Tasks
                        </button>
                        <button
                            onClick={() => handleTabChange('archives')}
                            className={`py-2 px-4 transition-colors duration-200 ${activeTab === 'archives'
                                    ? currentTheme === 'nature'
                                        ? 'border-b-2 border-nature-600 text-nature-800 dark:text-nature-300 font-medium'
                                        : 'border-b-2 border-indigo-600 text-indigo-800 dark:text-indigo-300 font-medium'
                                    : currentTheme === 'nature'
                                        ? 'text-gray-600 hover:text-nature-600 dark:text-gray-400 dark:hover:text-nature-300'
                                        : 'text-gray-500 hover:text-indigo-600 dark:text-gray-400 dark:hover:text-indigo-300'
                                }`}
                        >
                            Archived Tasks
                        </button>
                    </div>

                    {error && (
                        <div className="bg-red-100 dark:bg-red-900 border-l-4 border-red-500 text-red-700 dark:text-red-300 p-4 mb-4 rounded animate-fadeIn">
                            <div className="flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                    <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                                </svg>
                                <p>{error}</p>
                            </div>
                        </div>
                    )}          {activeTab === 'todos' && (
                        <>
                            <TodoInput onAdd={handleAdd} />
                            {todosLoading ? (
                                <div className="flex justify-center p-6">
                                    <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-indigo-600 dark:border-indigo-400"></div>
                                </div>
                            ) : (
                                <TodoList
                                    todos={mappedTodos || []}
                                    onToggle={handleArchive}
                                    onDelete={handleArchive}
                                    actionLabel="Archive"
                                    isLoading={todosLoading}
                                />
                            )}
                        </>
                    )}

                    {activeTab === 'archives' && (
                        <>
                            {archivesLoading ? (<div className="flex justify-center p-6">
                                <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-indigo-600 dark:border-indigo-400"></div>
                            </div>
                            ) : (
                                <TodoList
                                    todos={mappedArchives || []}
                                    onToggle={handleUnarchive}
                                    onDelete={handleDelete}
                                    actionLabel="Delete"
                                    toggleLabel="Unarchive"
                                    isLoading={archivesLoading}
                                />
                            )}
                        </>
                    )}          {/* Diagnostics Panel */}
                    {showDiagnostics && (
                        <div className="mt-8 border-t dark:border-gray-700 pt-6">
                            <h2 className="text-xl font-semibold mb-4 text-indigo-800 dark:text-indigo-300 flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z" />
                                </svg>
                                Diagnostics Tools
                            </h2>
                            <DiagnosticsPanel />
                        </div>
                    )}

                    <div className="mt-6 pt-4 border-t dark:border-gray-700">
                        <div className="text-center text-sm text-gray-500 dark:text-gray-400">
                            <button
                                onClick={() => activeTab === 'todos' ? loadTodos() : loadArchives()}
                                disabled={loading}
                                className={`text-indigo-600 dark:text-indigo-400 hover:underline focus:outline-none ${loading ? 'opacity-50 cursor-not-allowed' : ''}`}
                            >
                                {loading ? 'Refreshing...' : 'Refresh'}
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    )
}
